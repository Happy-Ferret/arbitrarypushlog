//
// Autogenerated by Thrift
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
var Thrift = require('thrift').Thrift;
var ttypes = module.exports = {};
var TCell = module.exports.TCell = function(args){
  this.value = null
  this.timestamp = null
if( args != null ){  if (null != args.value)
  this.value = args.value
  if (null != args.timestamp)
  this.timestamp = args.timestamp
}}
TCell.prototype = {}
TCell.prototype.read = function(input){
  var ret = input.readStructBegin()
  while (1)
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP)
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.value = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.I64) {
        this.timestamp = input.readI64()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

TCell.prototype.write = function(output){
  output.writeStructBegin('TCell')
  if (null != this.value) {
    output.writeFieldBegin('value', Thrift.Type.STRING, 1)
    output.writeString(this.value)
    output.writeFieldEnd()
  }
  if (null != this.timestamp) {
    output.writeFieldBegin('timestamp', Thrift.Type.I64, 2)
    output.writeI64(this.timestamp)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var ColumnDescriptor = module.exports.ColumnDescriptor = function(args){
  this.name = null
  this.maxVersions = 3
  this.compression = 'NONE'
  this.inMemory = false
  this.bloomFilterType = 'NONE'
  this.bloomFilterVectorSize = 0
  this.bloomFilterNbHashes = 0
  this.blockCacheEnabled = false
  this.timeToLive = -1
if( args != null ){  if (null != args.name)
  this.name = args.name
  if (null != args.maxVersions)
  this.maxVersions = args.maxVersions
  if (null != args.compression)
  this.compression = args.compression
  if (null != args.inMemory)
  this.inMemory = args.inMemory
  if (null != args.bloomFilterType)
  this.bloomFilterType = args.bloomFilterType
  if (null != args.bloomFilterVectorSize)
  this.bloomFilterVectorSize = args.bloomFilterVectorSize
  if (null != args.bloomFilterNbHashes)
  this.bloomFilterNbHashes = args.bloomFilterNbHashes
  if (null != args.blockCacheEnabled)
  this.blockCacheEnabled = args.blockCacheEnabled
  if (null != args.timeToLive)
  this.timeToLive = args.timeToLive
}}
ColumnDescriptor.prototype = {}
ColumnDescriptor.prototype.read = function(input){
  var ret = input.readStructBegin()
  while (1)
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP)
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.name = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.I32) {
        this.maxVersions = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRING) {
        this.compression = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 4:      if (ftype == Thrift.Type.BOOL) {
        this.inMemory = input.readBool()
      } else {
        input.skip(ftype)
      }
      break
      case 5:      if (ftype == Thrift.Type.STRING) {
        this.bloomFilterType = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 6:      if (ftype == Thrift.Type.I32) {
        this.bloomFilterVectorSize = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      case 7:      if (ftype == Thrift.Type.I32) {
        this.bloomFilterNbHashes = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      case 8:      if (ftype == Thrift.Type.BOOL) {
        this.blockCacheEnabled = input.readBool()
      } else {
        input.skip(ftype)
      }
      break
      case 9:      if (ftype == Thrift.Type.I32) {
        this.timeToLive = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

ColumnDescriptor.prototype.write = function(output){
  output.writeStructBegin('ColumnDescriptor')
  if (null != this.name) {
    output.writeFieldBegin('name', Thrift.Type.STRING, 1)
    output.writeString(this.name)
    output.writeFieldEnd()
  }
  if (null != this.maxVersions) {
    output.writeFieldBegin('maxVersions', Thrift.Type.I32, 2)
    output.writeI32(this.maxVersions)
    output.writeFieldEnd()
  }
  if (null != this.compression) {
    output.writeFieldBegin('compression', Thrift.Type.STRING, 3)
    output.writeString(this.compression)
    output.writeFieldEnd()
  }
  if (null != this.inMemory) {
    output.writeFieldBegin('inMemory', Thrift.Type.BOOL, 4)
    output.writeBool(this.inMemory)
    output.writeFieldEnd()
  }
  if (null != this.bloomFilterType) {
    output.writeFieldBegin('bloomFilterType', Thrift.Type.STRING, 5)
    output.writeString(this.bloomFilterType)
    output.writeFieldEnd()
  }
  if (null != this.bloomFilterVectorSize) {
    output.writeFieldBegin('bloomFilterVectorSize', Thrift.Type.I32, 6)
    output.writeI32(this.bloomFilterVectorSize)
    output.writeFieldEnd()
  }
  if (null != this.bloomFilterNbHashes) {
    output.writeFieldBegin('bloomFilterNbHashes', Thrift.Type.I32, 7)
    output.writeI32(this.bloomFilterNbHashes)
    output.writeFieldEnd()
  }
  if (null != this.blockCacheEnabled) {
    output.writeFieldBegin('blockCacheEnabled', Thrift.Type.BOOL, 8)
    output.writeBool(this.blockCacheEnabled)
    output.writeFieldEnd()
  }
  if (null != this.timeToLive) {
    output.writeFieldBegin('timeToLive', Thrift.Type.I32, 9)
    output.writeI32(this.timeToLive)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var TRegionInfo = module.exports.TRegionInfo = function(args){
  this.startKey = null
  this.endKey = null
  this.id = null
  this.name = null
  this.version = null
if( args != null ){  if (null != args.startKey)
  this.startKey = args.startKey
  if (null != args.endKey)
  this.endKey = args.endKey
  if (null != args.id)
  this.id = args.id
  if (null != args.name)
  this.name = args.name
  if (null != args.version)
  this.version = args.version
}}
TRegionInfo.prototype = {}
TRegionInfo.prototype.read = function(input){
  var ret = input.readStructBegin()
  while (1)
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP)
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.startKey = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRING) {
        this.endKey = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.I64) {
        this.id = input.readI64()
      } else {
        input.skip(ftype)
      }
      break
      case 4:      if (ftype == Thrift.Type.STRING) {
        this.name = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 5:      if (ftype == Thrift.Type.BYTE) {
        this.version = input.readByte()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

TRegionInfo.prototype.write = function(output){
  output.writeStructBegin('TRegionInfo')
  if (null != this.startKey) {
    output.writeFieldBegin('startKey', Thrift.Type.STRING, 1)
    output.writeString(this.startKey)
    output.writeFieldEnd()
  }
  if (null != this.endKey) {
    output.writeFieldBegin('endKey', Thrift.Type.STRING, 2)
    output.writeString(this.endKey)
    output.writeFieldEnd()
  }
  if (null != this.id) {
    output.writeFieldBegin('id', Thrift.Type.I64, 3)
    output.writeI64(this.id)
    output.writeFieldEnd()
  }
  if (null != this.name) {
    output.writeFieldBegin('name', Thrift.Type.STRING, 4)
    output.writeString(this.name)
    output.writeFieldEnd()
  }
  if (null != this.version) {
    output.writeFieldBegin('version', Thrift.Type.BYTE, 5)
    output.writeByte(this.version)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Mutation = module.exports.Mutation = function(args){
  this.isDelete = false
  this.column = null
  this.value = null
if( args != null ){  if (null != args.isDelete)
  this.isDelete = args.isDelete
  if (null != args.column)
  this.column = args.column
  if (null != args.value)
  this.value = args.value
}}
Mutation.prototype = {}
Mutation.prototype.read = function(input){
  var ret = input.readStructBegin()
  while (1)
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP)
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.BOOL) {
        this.isDelete = input.readBool()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRING) {
        this.column = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRING) {
        this.value = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Mutation.prototype.write = function(output){
  output.writeStructBegin('Mutation')
  if (null != this.isDelete) {
    output.writeFieldBegin('isDelete', Thrift.Type.BOOL, 1)
    output.writeBool(this.isDelete)
    output.writeFieldEnd()
  }
  if (null != this.column) {
    output.writeFieldBegin('column', Thrift.Type.STRING, 2)
    output.writeString(this.column)
    output.writeFieldEnd()
  }
  if (null != this.value) {
    output.writeFieldBegin('value', Thrift.Type.STRING, 3)
    output.writeString(this.value)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var BatchMutation = module.exports.BatchMutation = function(args){
  this.row = null
  this.mutations = null
if( args != null ){  if (null != args.row)
  this.row = args.row
  if (null != args.mutations)
  this.mutations = args.mutations
}}
BatchMutation.prototype = {}
BatchMutation.prototype.read = function(input){
  var ret = input.readStructBegin()
  while (1)
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP)
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.row = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.LIST) {
        {
          var _size0 = 0
          var rtmp3
          this.mutations = []
          var _etype3 = 0
          rtmp3 = input.readListBegin()
          _etype3 = rtmp3.etype
          _size0 = rtmp3.size
          for (var _i4 = 0; _i4 < _size0; ++_i4)
          {
            var elem5 = null
            elem5 = new ttypes.Mutation()
            elem5.read(input)
            this.mutations.push(elem5)
          }
          input.readListEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

BatchMutation.prototype.write = function(output){
  output.writeStructBegin('BatchMutation')
  if (null != this.row) {
    output.writeFieldBegin('row', Thrift.Type.STRING, 1)
    output.writeString(this.row)
    output.writeFieldEnd()
  }
  if (null != this.mutations) {
    output.writeFieldBegin('mutations', Thrift.Type.LIST, 2)
    {
      output.writeListBegin(Thrift.Type.STRUCT, this.mutations.length)
      {
        for(var iter6 in this.mutations)
        {
          if (this.mutations.hasOwnProperty(iter6))
          {
            iter6=this.mutations[iter6]
            iter6.write(output)
          }
        }
      }
      output.writeListEnd()
    }
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var TRowResult = module.exports.TRowResult = function(args){
  this.row = null
  this.columns = null
if( args != null ){  if (null != args.row)
  this.row = args.row
  if (null != args.columns)
  this.columns = args.columns
}}
TRowResult.prototype = {}
TRowResult.prototype.read = function(input){
  var ret = input.readStructBegin()
  while (1)
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP)
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.row = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.MAP) {
        {
          var _size7 = 0
          var rtmp3
          this.columns = {}
          var _ktype8 = 0
          var _vtype9 = 0
          rtmp3 = input.readMapBegin()
          _ktype8= rtmp3.ktype
          _vtype9= rtmp3.vtype
          _size7= rtmp3.size
          for (var _i11 = 0; _i11 < _size7; ++_i11)
          {
            key12 = null
            val13 = null
            key12 = input.readString()
            val13 = new ttypes.TCell()
            val13.read(input)
            this.columns[key12] = val13
          }
          input.readMapEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

TRowResult.prototype.write = function(output){
  output.writeStructBegin('TRowResult')
  if (null != this.row) {
    output.writeFieldBegin('row', Thrift.Type.STRING, 1)
    output.writeString(this.row)
    output.writeFieldEnd()
  }
  if (null != this.columns) {
    output.writeFieldBegin('columns', Thrift.Type.MAP, 2)
    {
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRUCT, Thrift.objectLength(this.columns))
      {
        for(var kiter14 in this.columns)        {
          if (this.columns.hasOwnProperty(kiter14))
          {
            var viter15 = this.columns[kiter14]
            output.writeString(kiter14)
            viter15.write(output)
          }
        }
      }
      output.writeMapEnd()
    }
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var IOError = module.exports.IOError = function(args){
  Thrift.TException.call(this, "IOError")
  this.name = "IOError"
  this.message = null
if( args != null ){  if (null != args.message)
  this.message = args.message
}}
Thrift.inherits(IOError, Thrift.TException)
IOError.prototype.read = function(input){
  var ret = input.readStructBegin()
  while (1)
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP)
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.message = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

IOError.prototype.write = function(output){
  output.writeStructBegin('IOError')
  if (null != this.message) {
    output.writeFieldBegin('message', Thrift.Type.STRING, 1)
    output.writeString(this.message)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var IllegalArgument = module.exports.IllegalArgument = function(args){
  Thrift.TException.call(this, "IllegalArgument")
  this.name = "IllegalArgument"
  this.message = null
if( args != null ){  if (null != args.message)
  this.message = args.message
}}
Thrift.inherits(IllegalArgument, Thrift.TException)
IllegalArgument.prototype.read = function(input){
  var ret = input.readStructBegin()
  while (1)
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP)
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.message = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

IllegalArgument.prototype.write = function(output){
  output.writeStructBegin('IllegalArgument')
  if (null != this.message) {
    output.writeFieldBegin('message', Thrift.Type.STRING, 1)
    output.writeString(this.message)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var AlreadyExists = module.exports.AlreadyExists = function(args){
  Thrift.TException.call(this, "AlreadyExists")
  this.name = "AlreadyExists"
  this.message = null
if( args != null ){  if (null != args.message)
  this.message = args.message
}}
Thrift.inherits(AlreadyExists, Thrift.TException)
AlreadyExists.prototype.read = function(input){
  var ret = input.readStructBegin()
  while (1)
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP)
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.message = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

AlreadyExists.prototype.write = function(output){
  output.writeStructBegin('AlreadyExists')
  if (null != this.message) {
    output.writeFieldBegin('message', Thrift.Type.STRING, 1)
    output.writeString(this.message)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

